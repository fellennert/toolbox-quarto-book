# Text Preprocessing and Featurization

After having learned about the basics of string manipulation, we are now turning to how you can turn your collection of documents, your corpus, into a representation that lends itself nicely to quantitative analyses of text. There are a couple of packages around which you can use for text mining, such as `quanteda` [@benoit_quanteda_2018], `tm` [@feinerer_text_2008], and `tidytext` [@silge_tidytext_2016], the latter being probably the most recent addition to them. A larger overview of relevant packages can be found on this [CRAN Task View](https://cran.r-project.org/web/views/NaturalLanguageProcessing.html).

```{r echo=FALSE, message=FALSE, warning=FALSE}
vembedr::embed_youtube("DCeGNYWlaVU")
```

As you could probably tell from its name, `tidytext` obeys the tidy data principles[^text-preprocessing-1]. "Every observation is a row" translates here to "every token has its own row" -- "token" not necessarily relating to a singular term, but also so-called n-grams. In the following, we will demonstrate what text mining using tidy principles can look like in R. For this, we will first cover the preprocessing of text using tidy data principles. Thereafter, we will delve into more advanced preprocessing such as the lemmatization of words and part-of-speech (POS) tagging using `spaCy` [@honnibal_spacy_2017]. Finally, different R packages are using different representations of text data. Depending on the task at hand, you will therefore have to be able to transform the data into the proper format. This will be covered in the final part.

[^text-preprocessing-1]: Each observation has its own row, each variable its own column, each value has its own cell, find more [here](https://cfss.uchicago.edu/notes/tidy-data/)

## Pre-processing with `tidytext`

The `sotu` package contains all of the so-called "State of the Union" addresses -- the president gives them to the congress annually -- since 1790.

```{r message=FALSE, warning=FALSE}
needs(hcandersenr, SnowballC, sotu, spacyr, stopwords, tidyverse, tidytext)

sotu_raw <- sotu_meta |> 
  mutate(text = sotu_text) |> 
  distinct(text, .keep_all = TRUE)

sotu_raw |> glimpse()
```

Now that the data are read in, I need to put them into the proper format and clean them. For this purpose, I take a look at the first entry of the tibble.

```{r}
sotu_raw |> slice(1) |> pull(text) |> str_sub(1, 500)
```

### `unnest_tokens()`

I will focus on the 20th-century SOTUs. Here, the `dplyr::between()` function comes in handy.

```{r}
sotu_20cent_raw <- sotu_raw |> 
  filter(between(year, 1900, 2000))

glimpse(sotu_20cent_raw)
```

In a first step, I bring the data into a form that facilitates manipulation: a tidy tibble. For this, I use `tidytext`'s `unnest_tokens()` function. It basically breaks the corpus up into tokens -- the respective words. Let's demonstrate that with a brief, intuitive example. \`

```{r}
toy_example <- tibble(
  text = "Look, this is a brief example for how tokenization works."
)

toy_example |> 
  unnest_tokens(output = token, 
                input = text)
```

Note that `unnest_tokens()` already reduces complexity for us by removing the comma and the full-stop and making everything lower-case.

```{r}
sotu_20cent_tokenized <- sotu_20cent_raw |> 
  unnest_tokens(output = token, input = text)
glimpse(sotu_20cent_tokenized)
```

The new tibble consists of `r sotu_20cent_tokenized |> nrow()` rows. Please note that usually, you have to put some sort of id column into your original tibble before tokenizing it, e.g., by giving each case -- representing a document, or chapter, or whatever -- a separate id (e.g., using `tibble::rowid_to_column()`). This does not apply here, because my original tibble came with a bunch of metadata (president, year, party) which serve as sufficient identifiers.

### Removal of unnecessary content

The next step is to remove stop words -- they are not necessary for the analyses I want to perform. The `stopwords` package has a nice list for English.

```{r}
stopwords_vec <- stopwords(language = "en")
stopwords(language = "de") # the german equivalent
#stopwords_getlanguages(source = "snowball") # find the languages that are available
#stopwords_getsources() # find the dictionaries that are available
```

Removing the stop words now is straight-forward:

```{r}
sotu_20cent_tokenized_nostopwords <- sotu_20cent_tokenized |> 
  filter(!token %in% stopwords_vec)
```

Another thing I forgot to remove are digits. They do not matter for the analyses either:

```{r}
sotu_20cent_tokenized_nostopwords_nonumbers <- sotu_20cent_tokenized_nostopwords |> 
  filter(!str_detect(token, "[:digit:]"))
```

The corpus now contains `r sotu_20cent_tokenized_nostopwords_nonumbers |> distinct(token) |> nrow()` different tokens, the so-called "vocabulary." `r (sotu_20cent_tokenized |> distinct(token) |> nrow()) - (sotu_20cent_tokenized_nostopwords_nonumbers |> distinct(token) |> nrow())` tokens were removed from the vocuabulary. This translates to a signifiant reduction in corpus size though, the new tibble only consists of `r sotu_20cent_tokenized_nostopwords_nonumbers |> nrow()` rows, basically a 50 percent reduction.

### Stemming

To decrease the complexity of the vocabulary even further, we can reduce the tokens to their stem using the `SnowballC` package and its function `wordStem()`:

```{r}
sotu_20cent_tokenized_nostopwords_nonumbers_stemmed <- sotu_20cent_tokenized_nostopwords_nonumbers |> 
  mutate(token_stemmed = wordStem(token, language = "en"))

#SnowballC::getStemLanguages() # if you want to know the abbreviations for other languages as well
```

Maybe I should also remove insignificant words, i.e., ones that appear less than 0.05 percent of the time.

```{r}
n_rows <- nrow(sotu_20cent_tokenized_nostopwords_nonumbers_stemmed)
sotu_20cent_tokenized_nostopwords_nonumbers_stemmed |> 
  group_by(token_stemmed) |> 
  filter(n() > n_rows/2000)
```

These steps have brought down the vocabulary from `r sotu_20cent_tokenized_nostopwords_nonumbers |> distinct(token) |> nrow()` to `r sotu_20cent_tokenized_nostopwords_nonumbers_stemmed |> distinct(token_stemmed) |> nrow()`.

### In a nutshell

Well, all those things could also be summarized in one nice cleaning pipeline:

```{r}
sotu_20cent_clean <- sotu_raw |> 
  filter(between(year, 1900, 2000)) |> 
  unnest_tokens(output = token, input = text) |> 
  anti_join(get_stopwords(), by = c("token" = "word")) |> 
  filter(!str_detect(token, "[0-9]")) |> 
  mutate(token = wordStem(token, language = "en")) |> 
  group_by(token) |> 
  filter(n() > n_rows/2000)
```

Now I have created a nice tibble containing the SOTU addresses of the 20th century in a tidy format. This is a great point of departure for subsequent analyses.

### Exercises

1.  Download Twitter timeline data (`timelines <- read_csv("https://www.dropbox.com/s/dpu5m3xqz4u4nv7/tweets_house_rep_party.csv?dl=1") |> filter(!is.na(party))`. Let's look at abortion-related tweets and how the language may differ between parties. Filter relevant tweets using a vector of keywords and a regular expression (hint: `filter(str_detect(text, str_c(keywords, collapse = "|")))`). Preprocess the Tweets as follows:

```{=html}
<!-- -->
```
a.  Unnest the tokens.
b.  Remove stop words.
c.  Perform stemming.

```{r eval=FALSE}
needs(tidyverse, tidytext, stopwords, SnowballC)

timelines <- read_csv("https://www.dropbox.com/s/dpu5m3xqz4u4nv7/tweets_house_rep_party.csv?dl=1") |> 
  filter(!is.na(party))

keywords <- c("abortion", "prolife", " roe ", " wade ", "roevswade", "baby", "fetus", "womb", "prochoice", "leak")

preprocessed <- timelines |> 
  rowid_to_column("doc_id") |> 
  filter(str_detect(text, str_c(keywords, collapse = "|"))) |> 
  unnest_tokens(word, text) |> 
  anti_join(get_stopwords()) |> 
  mutate(stemmed = wordStem(word))
```

## Lemmatization, Named Entity Recognition, POS-tagging, and Dependency Parsing with `spaCyR`

Advanced operations to the end of extracting information and annotating text (and more!) can be done with `spaCyr` [@benoit_spacyr_2020]. `spaCyr` is an R wrapper around the `spaCy` Python package and, therefore, a bit tricky to install at first. You can find instructions [here](https://spacyr.quanteda.io/articles/using_spacyr.html).

```{r echo=FALSE, message=FALSE, warning=FALSE}
vembedr::embed_youtube("SdlDcrfO8Dc")
```

The functionalities `spaCyr` offers you are the following[^text-preprocessing-2]:

[^text-preprocessing-2]: overview copied from the webpage

-   parsing texts into tokens or sentences;
-   lemmatizing tokens;
-   parsing dependencies (to identify the grammatical structure of the sentence); and
-   identifying, extracting, or consolidating token sequences that form named entities or noun phrases.

In brief, preprocessing with `spaCyr` is computationally more expensive than using, for instance, `tidytext`, but it will give you more [accurate lemmatization instead of "stupid," rule-based stemming.](https://stackoverflow.com/questions/1787110/what-is-the-difference-between-lemmatization-vs-stemming). Also, it allows you to break up documents into smaller entities, sentences, which might be more suitable, e.g., as input for classifiers (since sentences tend to be about one topic, they allow for more fine-grained analyses). Part-of-speech (POS) tagging basically provides you with the functions of the different terms within the sentence. This might prove useful for tasks such as sentiment analysis. The final task `spaCyr` can help you with is Named Entity Recognition (NER) which can be used for tasks such as sampling relevant documents.

### Initializing spaCy

Before using `spaCyr`, it needs to be initialized. What happens during this process is that R basically opens a connection to Python so that it can then run the `spaCyr` functions in Python's `spaCy`. Once you have set up everything properly (see [instructions](https://spacyr.quanteda.io/articles/using_spacyr.html)), you can initialize it using `spacy_initialize(model)`. Different language models can be specified and an overview can be found [here](https://spacy.io/usage/models#languages). Note that a process of `spaCy` is started when you `spacy_initialize()` and continues running in the background. Hence, once you don't need it anymore, or want to load a different model, you should `spacy_finalize()`.

```{r}
needs(spacyr)
spacy_initialize(model = "en_core_web_sm")
# to download new model -- here: French
#spacy_finalize()
#spacy_download_langmodel(model = "fr_core_news_sm")
#spacy_initialize(model = "fr_core_news_sm") #check that it has worked

spacy_finalize()
#spacy_initialize(model = "de_core_web_sm") # for German
```

### `spacy_parse()`

`spaCyr`'s workhorse function is `spacy_parse()`. It takes a character vector or [TIF-compliant data frame](https://github.com/ropensci/tif). The latter is basically a tibble containing at least two columns, one named `doc_id` with unique document ids and one named `text`, containing the respective documents.

```{r}
tif_toy_example <- tibble(
  doc_id = "doc1",
  text = "Look, this is a brief example for how tokenization works. This second sentence allows me to demonstrate another functionality of spaCy."
)

toy_example_vec <- tif_toy_example$text

spacy_parse(tif_toy_example)
```

The output of `spacy_parse()` and the sotu-speeches looks as follows:

```{r}
sotu_speeches_tif <- sotu_meta |> 
  mutate(text = sotu_text) |> 
  distinct(text, .keep_all = TRUE) |> 
  filter(between(year, 1990, 2000)) |> 
  group_by(year) |> 
  summarize(text = str_c(text, collapse = " ")) |> 
  select(doc_id = year, text)

glimpse(sotu_speeches_tif)

sotu_parsed <- spacy_parse(sotu_speeches_tif,
                           pos = TRUE,
                           tag = TRUE,
                           lemma = TRUE,
                           entity = TRUE,
                           dependency = TRUE,
                           nounphrase = TRUE,
                           multithread = TRUE)

# if you haven't installed spacy yet, uncomment and run the following line
#sotu_parsed <- read_rds("https://github.com/fellennert/sicss-paris-2023/raw/main/code/sotu_parsed.rds")
```

Note that this is already fairly similar to the output of `tidytext`'s `unnest_tokens()` function. The advantages are that the lemmas are more accurate, that we have a new sub-entity -- sentences --, and that there is now more information on the type and meanings of the words.

### POS tags, NER, and nounphrases

The abbreviations in the `pos` column follow the format of [Universal POS tags](https://universaldependencies.org/u/pos/all.html). Entities can be extracted by passing the parsed object on to `entity_extract()`.

```{r}
entity_extract(sotu_parsed, type = "all") |> glimpse()
```

The following entities are recognized (overview taken from [this article](https://towardsdatascience.com/explorations-in-named-entity-recognition-and-was-eleanor-roosevelt-right-671271117218)):

-   PERSON: People, including fictional.
-   NORP: Nationalities or religious or political groups.
-   FAC: Buildings, airports, highways, bridges, etc.
-   ORG: Companies, agencies, institutions, etc.
-   GPE: Countries, cities, states.
-   LOC: Non-GPE locations, mountain ranges, bodies of water.
-   PRODUCT: Objects, vehicles, foods, etc. (Not services.)
-   EVENT: Named hurricanes, battles, wars, sports events, etc.
-   WORK_OF_ART: Titles of books, songs, etc.
-   LAW: Named documents made into laws.
-   LANGUAGE: Any named language.
-   DATE: Absolute or relative dates or periods.
-   TIME: Times smaller than a day.
-   PERCENT: Percentage, including "%".
-   MONEY: Monetary values, including unit.
-   QUANTITY: Measurements, as of weight or distance.
-   ORDINAL: "first," "second," etc.
-   CARDINAL: Numerals that do not fall under another type.

To properly represent entities in our corpus, you can use `entity_consolidate()`. This collapses words that belong to the same entity into single tokens (e.g., "the" "white" "house" becomes "the_white_house").

```{r}
entity_consolidate(sotu_parsed) |> glimpse()
```

If you want to extract only nouns, you can simply filter them.

```{r}
sotu_parsed |> 
  entity_consolidate() |> 
  filter(pos == "NOUN") |> 
  glimpse()
```

However, a better way is to extract the "complete" noun phrases:

```{r}
nounphrase_extract(sotu_parsed) |> glimpse()
```

Usually, entities and noun phrases can give you a good idea of what texts are about. Therefore, you might want to only extract them without parsing the entire text.

```{r}
spacy_extract_entity(sotu_speeches_tif |> slice(1:3)) |> glimpse()
spacy_extract_nounphrases(sotu_speeches_tif |> slice(1:3)) |> glimpse()
```

### Exercises

2.  Perform the same steps as in exercise 1 but using `spacyr`. What works better, lemmatization or stemming?

```{r eval=FALSE}
needs(spacyr)
spacy_initialize(model = "en_core_web_sm")

timelines_meta <- timelines |> 
  filter(str_detect(text, str_c(keywords, collapse = "|"))) |> 
  rowid_to_column("doc_id") |> 
  select(-text)

timelines_spacy <- timelines |> 
  filter(str_detect(text, str_c(keywords, collapse = "|"))) |> 
  select(text) |> 
  rowid_to_column("doc_id") |> 
  spacy_parse(entity = FALSE) |> 
  anti_join(get_stopwords(), by = c("token" = "word"))
```

## Converting between formats

While the `tidytext` format lends itself nicely to "basic" operations and visualizations, you will have to use different representations of text data for other applications such as topic models or word embeddings. On the other hand, you might want to harness, for instance, the `ggplot2` package for visualization. In this case, you will need to project the data into a tidy format. The former operations are performed using multiple `cast_.*()` functions, the latter using the `tidy()` function from the `broom` package whose purpose is to bring data from foreign structures to tidy representations.

In the following, I will briefly explain common representations and the packages that use them. Thereby, I draw heavily on the [chapter in Tidy Text Mining with R that is dedicated to the topic](https://www.tidytextmining.com/dtm.html).

### Document-term matrix

A document-term matrix contains rows that represent a document and columns that represent terms. The values usually correspond to how often the term appears in the respective document.

In R, a common implementation of DTMs is the `DocumentTermMatrix` class in the `tm` package. The `topicmodels` package which we will use for performing LDA comes with a collection of example data.

```{r}
library(topicmodels)
data("AssociatedPress")

class(AssociatedPress)
AssociatedPress
```

This data set contains 2246 Associated Press articles which consist of 10,473 different terms. Moreover, the matrix is 99% sparse, meaning that 99% of word-document pairs are zero. The weighting is by term frequency, hence the values correspond to the number of appearances a word has in an article.

```{r}
AssociatedPress |> 
  head(2) |> 
  as.matrix() %>%
  .[, 1:10]
```

Bringing these data into a tidy format is performed as follows:

```{r}
associated_press_tidy <- tidy(AssociatedPress)

glimpse(associated_press_tidy)
```

Transforming the data set into a DTM, the opposite operation, is achieved using `cast_dtm(data, document, term, value)`:

```{r}
associated_press_dfm <- associated_press_tidy |> 
  cast_dtm(document, term, count)

associated_press_dfm |> 
  head(2) |> 
  as.matrix() %>%
  .[, 1:10]
```

### Document-feature matrix

The so-called document-feature matrix is the data format used in the `quanteda` package. It is basically a document-term matrix, but the authors of the `quanteda` package chose the term feature over term to be more accurate:

> "We call them 'features' rather than terms, because features are more general than terms: they can be defined as raw terms, stemmed terms, the parts of speech of terms, terms after stopwords have been removed, or a dictionary class to which a term belongs. Features can be entirely general, such as ngrams or syntactic dependencies, and we leave this open-ended."

```{r}
data("data_corpus_inaugural", package = "quanteda")
inaug_dfm <- data_corpus_inaugural |>
  quanteda::tokens() |>
  quanteda::dfm(verbose = FALSE)

inaug_dfm
```

This, again, can just be `tidy()`ed.

```{r}
inaug_tidy <- tidy(inaug_dfm)

glimpse(inaug_tidy)
```

Of course, the resulting tibble can now be cast back into the DFM format using `cast_dfm(data, document, term, value)`. Here, the value corresponds to the number of appearances of the term in the respective document.

```{r}
inaug_tidy |> 
  cast_dfm(document, term, count)
```

### Corpus objects

Another common way of storing data is in so-called corpora. This is usually a collection of raw documents and metadata. An example would be the collection of State of the Union speeches we worked with earlier. The `tm` package has a class for corpora.

```{r}
data("acq", package = "tm")

acq

#str(acq |> head(1))
```

It is basically a list containing different elements that refer to metadata or the content. This is a nice and effective framework for storing documents, yet it does not lend itself nicely for analysis with tidy tools. You can use `tidy()` to clean it up a bit:

```{r}
acq_tbl <- acq |> 
  tidy()
```

This results in a tibble that contains the relevant metadata and a `text` column. A good point of departure for subsequent tidy analyses.

## First analyses

```{r echo=FALSE, message=FALSE, warning=FALSE}
vembedr::embed_youtube("-87TW9ihg4A")
```

A common task in the quantitative analysis of text is to determine how documents differ from each other concerning word usage. This is usually achieved by identifying words that are particular for one document but not for another. These words are referred to by @monroe_fightin_2008 as *fighting words* or, by @grimmer_text_2022, *discriminating words*. To use the techniques that will be presented today, an already existing organization of the documents is assumed.

The most simple approach to determine which words are more correlated to a certain group of documents is by merely counting them and determining their proportion in the document groups. For illustratory purposes, I use fairy tales from H.C. Andersen which are contained in the `hcandersenr` package.

```{r message=FALSE, warning=FALSE}
fairytales <- hcandersen_en |> 
  filter(book %in% c("The princess and the pea",
                     "The little mermaid",
                     "The emperor's new suit"))

fairytales_tidy <- fairytales |> 
  unnest_tokens(token, text)
```

### Counting words per document

For a first, naive analysis, I can merely count the times the terms appear in the texts. Since the text is in `tidytext` format, I can do so using means from traditional `tidyverse` packages. I will then visualize the results with a bar plot.

```{r}
fairytales_top10 <- fairytales_tidy |> 
  group_by(book) |> 
  count(token) |> 
  slice_max(n, n = 10, with_ties = FALSE)
```

```{r}
fairytales_top10 |> 
  ggplot()  +
  geom_col(aes(x = n, y = reorder_within(token, n, book))) +
  scale_y_reordered() +
  labs(y = "token") +
  facet_wrap(vars(book), scales = "free") +
  theme(strip.text.x = element_blank())
```

It is quite hard to draw inferences on which plot belongs to which book since the plots are crowded with stopwords. However, there are pre-made stopword lists I can harness to remove some of this "noise" and perhaps catch a bit more signal for determining the books.

```{r}
# get_stopwords()
# stopwords_getsources()
# stopwords_getlanguages(source = "snowball")

fairytales_top10_nostop <- fairytales_tidy |> 
  anti_join(get_stopwords(), by = c("token" = "word")) |> 
  group_by(book) |> 
  count(token) |> 
  slice_max(n, n = 10, with_ties = FALSE)
```

```{r}
fairytales_top10_nostop |> 
  ggplot()  +
  geom_col(aes(x = n, y = reorder_within(token, n, book))) +
  scale_y_reordered() +
  labs(y = "token") +
  facet_wrap(vars(book), scales = "free_y") +
  scale_x_continuous(breaks = scales::pretty_breaks()) +
  theme(strip.text.x = element_blank())
```

This already looks quite nice, it is quite easy to see which plot belongs to the respective book.

### TF-IDF

A better definition of words that are particular to a group of documents is "the ones that appear often in one group but rarely in the other one(s)". So far, the measure of term frequency only accounts for how often terms are used in the respective document. I can take into account how often it appears in other documents by including the inverse document frequency. The resulting measure is called tf-idf and describes "the frequency of a term adjusted for how rarely it is used." [@silge_tidytext_2016: 31] If a term is rarely used overall but appears comparably often in a singular document, it might be safe to assume that it plays a bigger role in that document.

The tf-idf of a word in a document is commonly[^text-preprocessing-3]. One implementation is calculated as follows:

[^text-preprocessing-3]: Note that multiple implementations exist, for an overview see, for instance, @manning_introduction_2008

$$w_{i,j}=tf_{i,j}\times ln(\frac{N}{df_{i}})$$

--\> $tf_{i,j}$: number of occurrences of term $i$ in document $j$

--\> $df_{i}$: number of documents containing $i$

--\> $N$: total number of documents

Note that the $ln$ is included so that words that appear in all documents -- and do therefore not have discriminatory power -- will automatically get a value of 0. This is because $ln(1) = 0$. On the other hand, if a term appears in, say, 4 out of 20 documents, its ln(idf) is $ln(20/4) = ln(5) = 1.6$.

The `tidytext` package provides a neat implementation for calculating the tf-idf called `bind_tfidf()`. It takes as input the columns containing the `term`, the `document`, and the document-term counts `n`.

```{r}
fairytales_top10_tfidf <- fairytales_tidy |> 
  group_by(book) |> 
  count(token) |> 
  bind_tf_idf(token, book, n) |> 
  slice_max(tf_idf, n = 10)
```

```{r}
fairytales_top10_tfidf |> 
  ggplot()  +
  geom_col(aes(x = tf_idf, y = reorder_within(token, tf_idf, book))) +
  scale_y_reordered() +
  labs(y = "token") +
  facet_wrap(vars(book), scales = "free") +
  theme(strip.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

Pretty good already! All the fairytales can be clearly identified. A problem with this representation is that I cannot straightforwardly interpret the x-axis values (they can be removed by uncommenting the last four lines). A way to mitigate this is using odds.

Another shortcoming becomes visible when I take the terms with the highest TF-IDF as compared to all other fairytales.

```{r}
tfidf_vs_full <- hcandersenr::hcandersen_en |> 
  unnest_tokens(output = token, input = text) |> 
  count(token, book) |> 
  bind_tf_idf(book, token, n) |> 
  filter(book %in% c("The princess and the pea",
                     "The little mermaid",
                     "The emperor's new suit")) 

plot_tf_idf <- function(df, group_var){
  df |> 
    group_by({{ group_var }}) |> 
    slice_max(tf_idf, n = 10, with_ties = FALSE) |> 
    ggplot()  +
    geom_col(aes(x = tf_idf, y = reorder_within(token, tf_idf, {{ group_var }}))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars({{ group_var }}), scales = "free") +
    #theme(strip.text.x = element_blank()) +
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank())
} 
  
plot_tf_idf(tfidf_vs_full, book)
```

The tokens are far too specific to make any sense. Introducing a lower threshold (i.e., limiting the analysis to terms that appear at least x times in the document) might mitigate that. Yet, this threshold is of course arbitrary.

```{r}
tfidf_vs_full |> 
  #group_by(token) |> 
  filter(n > 3) |> 
  ungroup() |> 
  plot_tf_idf(book)
```

### Exercises

3.  Count the terms per party.

```{=html}
<!-- -->
```
a.  Do you see party-specific differences with regard to their ten most common terms (hint: `slice_max(n, n = 10, with_ties = FALSE)`)?

```{r eval=FALSE}
df <- preprocessed |> 
  count(stemmed, party) |> 
  group_by(party) |> 
  slice_max(n, n = 10, with_ties = FALSE)
  
df |> 
  group_by(party) |> 
  ggplot()  +
    geom_col(aes(x = n, y = reorder_within(stemmed, n, party))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars(party), scales = "free") 
```

b.  Is there more words you should add to your stopwords list? Remove these terms using `filter(str_detect())` and a regex.

```{r eval=FALSE}
more_stopwords <- c("t.co", "http", "amp") 
df |> 
  filter(!str_detect(stemmed, str_c(more_stopwords, collapse = "|"))) |> 
  group_by(party) |> 
  ggplot()  +
    geom_col(aes(x = n, y = reorder_within(stemmed, n, party))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars(party), scales = "free") 
```

c.  Do the same thing but using the spacy output and filtering only `NOUN`s and `PROPN`ouns.

```{r eval=FALSE}
timelines_spacy |> 
  filter(pos %in% c("PROPN", "NOUN")) |> 
  left_join(timelines_meta |> 
              mutate(doc_id = as.character(doc_id)), by = "doc_id") |> 
  count(token, party) |>
  group_by(party) |> 
  slice_max(n, n = 10, with_ties = FALSE) |> 
  ggplot()  +
    geom_col(aes(x = n, y = reorder_within(token, n, party))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars(party), scales = "free") 
```

d.  Again, is there stuff to be removed? Do so using a Regex.

```{r eval=FALSE}
timelines_spacy |> 
  filter(pos %in% c("PROPN", "NOUN"),
         !str_detect(token, "^@|[^a-z]|^amp$")) |> 
  left_join(timelines_meta |> 
              mutate(doc_id = as.character(doc_id)), by = "doc_id") |> 
  count(token, party) |>
  group_by(party) |> 
  slice_max(n, n = 10, with_ties = FALSE) |> 
  ggplot()  +
    geom_col(aes(x = n, y = reorder_within(token, n, party))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars(party), scales = "free") 
```

4.  Do the same thing as in 3. but use TF-IDF instead of raw counts. How does this alter your results?

```{r eval=FALSE}
df_tf_idf <- preprocessed |> 
  count(word, party) |> 
  bind_tf_idf(word, party, n) |> 
  group_by(party) |> 
  slice_max(tf_idf, n = 10, with_ties = FALSE)
  
df_tf_idf |> 
  group_by(party) |> 
  ggplot()  +
    geom_col(aes(x = tf_idf, y = reorder_within(word, tf_idf, party))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars(party), scales = "free") 


timelines_spacy |> 
  #filter(pos %in% c("PROPN", "NOUN")) |> 
  left_join(timelines_meta |> 
              mutate(doc_id = as.character(doc_id)), by = "doc_id") |> 
  count(token, party) |>
  filter(str_detect(token, "[a-z]")) |> 
  filter(!str_detect(token, "^@")) |> 
  bind_tf_idf(token, party, n) |> 
  group_by(party) |> 
  slice_max(tf_idf, n = 10, with_ties = FALSE) |> 
  ggplot()  +
    geom_col(aes(x = tf_idf, y = reorder_within(token, tf_idf, party))) +
    scale_y_reordered() +
    labs(y = "token") +
    facet_wrap(vars(party), scales = "free") 
```

## Dictionary-based Analysis

```{r echo=FALSE, message=FALSE, warning=FALSE}
vembedr::embed_youtube("HnVfx1Jy09s")
```

Sentiment analyses are fairly easy when you have your data in tidy text format. As they basically consist of matching the particular words' sentiment values to the corpus, this can be done with an `inner_join()`. `tidytext` comes with four dictionaries: bing, loughran, afinn, and nrc:

```{r}
walk(c("bing", "loughran", "afinn", "nrc"), ~get_sentiments(lexicon = .x) |> 
       head() |> 
       print())
```

As you can see here, the dictionaries are mere tibbles with two columns: "word" and "sentiment". For easier joining, I should rename my column "token" to word.

```{r message=FALSE, warning=FALSE}
needs(magrittr)
sotu_20cent_clean %<>% rename(word = token)
```

The AFINN dictionary is the only one with numeric values. You might have noticed that its words are not stemmed. Hence, I need to do this before I can join it with my tibble. To get the sentiment value per document, I need to average it.

```{r message=FALSE, warning=FALSE}
sotu_20cent_afinn <- get_sentiments("afinn") |> 
  mutate(word = wordStem(word, language = "en")) |> 
  inner_join(sotu_20cent_clean) |> 
  group_by(year) |> 
  summarize(sentiment = mean(value))
```

Thereafter, I can just plot it:

```{r message=FALSE, warning=FALSE}
sotu_20cent_afinn |> 
  ggplot() +
  geom_line(aes(x = year, y = sentiment))
```

That's a bit hard to interpret. `geom_smooth()` might help:

```{r message=FALSE, warning=FALSE}
sotu_20cent_afinn |> 
  ggplot() +
  geom_smooth(aes(x = year, y = sentiment))
```

Interesting. When you think of the tone in the SOTU addresses as a proxy measure for the circumstances, the worst phase appears to be during the 1920s and 1930s -- might make sense given the then economic circumstances, etc. The maximum was in around the 1960s and since then it has, apparently, remained fairly stable.

### Assessing the results

However, we have no idea whether we are capturing some valid signal or not. Let's look at what drives those classifications the most:

```{r message=FALSE, warning=FALSE}
sotu_20cent_contribution <- get_sentiments("afinn") |> 
  mutate(word = wordStem(word, language = "en")) |> 
  inner_join(sotu_20cent_clean)  |>
  group_by(word) |>
  summarize(occurences = n(),
            contribution = sum(value))
```

```{r message=FALSE, warning=FALSE}
sotu_20cent_contribution |>
  slice_max(contribution, n = 10) |>
  bind_rows(sotu_20cent_contribution |> slice_min(contribution, n = 10)) |> 
  mutate(word = reorder(word, contribution)) |>
  ggplot(aes(contribution, word, fill = contribution > 0)) +
  geom_col(show.legend = FALSE) +
  labs(y = NULL)
```

Let's split this up per decade:

```{r message=FALSE, warning=FALSE}
get_sentiments("afinn") |> 
  mutate(word = wordStem(word, language = "en")) |> 
  inner_join(sotu_20cent_clean) |>
  mutate(decade = ((year - 1900)/10) |> floor()) |>
  group_by(decade, word) |>
  summarize(occurrences = n(),
            contribution = sum(value)) |> 
  slice_max(contribution, n = 5) |>
  bind_rows(get_sentiments("afinn") |> 
              mutate(word = wordStem(word, language = "en")) |> 
              inner_join(sotu_20cent_clean) |>
              mutate(decade = ((year - 1900)/10) |> floor()) |>
              group_by(decade, word) |>
              summarize(occurrences = n(),
                        contribution = sum(value)) |> 
              slice_min(contribution, n = 5)) |> 
  mutate(word = reorder_within(word, contribution, decade)) |>
  ggplot(aes(contribution, word, fill = contribution > 0)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~decade, ncol = 4, scales = "free") +
  scale_y_reordered()
```

### Assessing the quality of the rating

We need to assess the reliability of our classification (would different raters come to the same conclusion; and, if we compare it to a gold standard, how does the classification live up to its standards). One measure we can use here is Krippendorf's Alpha which is defined as

$$\alpha = \frac{D_o}{D_e}$$

where $D_{o}$ is the observed disagreement and $D_{e}$ is the expected disagreement (by chance). The calculation of the measure is far more complicated, but R can easily take care of that -- we just need to feed it with proper data. For this example I use a commonly used benchmark data set containing IMDb reviews of movies and whether they're positive or negative.

```{r message=FALSE, warning=FALSE}
imdb_reviews <- read_csv("https://www.dropbox.com/scl/fi/psgj6ze6at3zovildm728/imdb_reviews.csv?rlkey=ve2s02ydosbweemalvskyiu4s&dl=1")

glimpse(imdb_reviews)

imdb_reviews_afinn <- imdb_reviews |> 
  rowid_to_column("doc") |> 
  unnest_tokens(token, text) |> 
  anti_join(get_stopwords(), by = c("token" = "word")) |> 
  mutate(stemmed = wordStem(token)) |> 
  inner_join(get_sentiments("afinn") |> mutate(stemmed = wordStem(word))) |> 
  group_by(doc) |> 
  summarize(sentiment = mean(value)) |> 
  mutate(sentiment_afinn = case_when(sentiment > 0 ~ "positive",
                                     TRUE ~ "negative") |> 
           factor(levels = c("positive", "negative")))
```

Now we have two classifications, one "gold standard" from the data and the one obtained through AFINN.

```{r message=FALSE, warning=FALSE}
review_coding <- imdb_reviews |> 
  mutate(true_sentiment = sentiment |> 
           factor(levels = c("positive", "negative"))) |> 
  select(-sentiment) |> 
  rowid_to_column("doc") |> 
  left_join(imdb_reviews_afinn |> select(doc, sentiment_afinn)) 
```

First, we can check how often AFINN got it right, the accuracy:

```{r message=FALSE, warning=FALSE}
sum(review_coding$true_sentiment == review_coding$sentiment_afinn, na.rm = TRUE)/25000
```

However, accuracy is not a perfect metric because it doesn't tell you anything about the details. For instance, your classifier might just predict "positive" all of the time. If your gold standard has 50 percent "positive" cases, the accuracy would lie at 0.5. We can address this using the following measures.

For the calculation of Krippendorff's Alpha, the data must be in a different format: a matrix containing with documents as columns and the respective ratings as rows.

```{r message=FALSE, warning=FALSE}
needs(irr)
mat <- review_coding |> 
  select(-text) |> 
  as.matrix() |> 
  t()

mat[1:3, 1:5]
colnames(mat) <- mat[1,]

mat <- mat[2:3,]
mat[1:2, 1:5]

irr::kripp.alpha(mat, method = "nominal")
```

Good are alpha values of around 0.8 -- AFINN missed that one.

Another way to evaluate the quality of classification is through a confusion matrix.

![](figures/confusion_matrix.png)

Now we can calculate precision (when it predicts "positive", how often is it correct), recall/sensitivity (when it is "positive", how often is this predicted), specificity (when it's "negative", how often is it actually negative). The [F1-score](https://deepai.org/machine-learning-glossary-and-terms/f-score) is the harmonic mean of precision and recall and defined as $F_1 = \frac{2}{\frac{1}{recall}\times \frac{1}{precision}} = 2\times \frac{precision\times recall}{precision + recall}$ and the most commonly used measure to assess the accuracy of the classification. The closer to 1 it is, the better. You can find a more thorough description of the confusion matrix and the different measures in [this blog post](https://machinelearningmastery.com/confusion-matrix-machine-learning/).

We can do this in R using the `caret` package.

```{r message=FALSE, warning=FALSE}
needs(caret)
confusion_matrix <- confusionMatrix(data = review_coding$sentiment_afinn, 
                                    reference = review_coding$true_sentiment,
                                    positive = "positive")
confusion_matrix$byClass
```

### Exercises

5.  Take the abortion-related Tweets. Check for sentiment differences in parties. Use the AFINN dictionary. Plot your results.

```{r eval=FALSE}
sent_per_party <- preprocessed |> 
  inner_join(get_sentiments("afinn")) |> 
  mutate(word_sent = case_when(value > 0 ~ "positive",
                                value < 0 ~ "negative"))
sent_per_party |> 
  ggplot() +
  geom_bar(aes(word_sent)) +
  facet_wrap(vars(party))         
         
sent_per_doc <- preprocessed |> 
  inner_join(get_sentiments("afinn")) |> 
  group_by(doc_id, party) |> 
  summarize(mean_sent = mean(value)) |> 
  mutate(tweet_sent = case_when(mean_sent > 0 ~ "positive",
                                mean_sent < 0 ~ "negative",
                                TRUE ~ "neutral"))

sent_per_doc |> 
  ggplot() +
  geom_bar(aes(tweet_sent)) +
  facet_wrap(vars(party))
```

6.  Have a look at different dictionaries (e.g., Bing or Loughran). Check the words that contributed the most. Do you see any immediate ambiguities or flaws?

```{r eval=FALSE}
# afinn
tweets_abortion_tidy_contribution_afinn <- preprocessed |> 
  inner_join(get_sentiments("afinn")) |> 
  group_by(party, word) |>
  summarize(contribution = sum(value))

bind_rows(
  tweets_abortion_tidy_contribution_afinn |> 
    filter(party == "D") |> 
    slice_max(contribution, n = 10, with_ties = FALSE) |> 
    mutate(type = "pos"),
  tweets_abortion_tidy_contribution_afinn |> 
    filter(party == "D") |> 
    slice_min(contribution, n = 10, with_ties = FALSE) |> 
    mutate(type = "neg"),
  tweets_abortion_tidy_contribution_afinn |> 
    filter(party == "R") |> 
    slice_max(contribution, n = 10, with_ties = FALSE) |> 
    mutate(type = "pos"),
  tweets_abortion_tidy_contribution_afinn |> 
    filter(party == "R") |> 
    slice_min(contribution, n = 10, with_ties = FALSE) |> 
    mutate(type = "neg")
) |> 
  mutate(word = reorder_within(word, contribution, party)) |>
  ggplot() +
  geom_col(aes(contribution, word), show.legend = FALSE) +
    scale_y_reordered() +
    facet_wrap(vars(party, type), scales = "free")

# loughran
needs(ggpubr)

tweets_abortion_tidy_contribution_loughran <- preprocessed |> 
  inner_join(get_sentiments("loughran")) |> 
  count(party, sentiment, word) |> 
  group_by(party, sentiment) |> 
  slice_max(n, n = 10, with_ties = FALSE) |> 
  group_split()

tweets_abortion_tidy_contribution_loughran |> 
  map(\(x) x |> 
        mutate(word = reorder_within(word, n, party)) |> 
        slice_max(n, n = 10) |> 
        ggplot() +
        geom_col(aes(n, word), show.legend = FALSE) +
        scale_y_reordered() +
        labs(title = x[["sentiment"]][1])
  ) |> 
  ggarrange(plotlist = _)
  
# bing
tweets_abortion_tidy_contribution_bing <- preprocessed |> 
  inner_join(get_sentiments("bing")) |> 
  count(party, sentiment, word) |> 
  group_by(party, word, sentiment) |> 
  summarize(contribution = sum(n)) |> 
  group_by(party, sentiment) |> 
  slice_max(contribution, n = 10, with_ties = FALSE) |> 
  mutate(contribution = case_when(
    sentiment == "negative" ~ contribution * (-1),
    TRUE ~ contribution
  ))

tweets_abortion_tidy_contribution_bing |> 
  mutate(word = reorder_within(word, contribution, party)) |>
  ggplot() +
  geom_col(aes(contribution, word), show.legend = FALSE) +
    scale_y_reordered() +
    facet_wrap(vars(party, sentiment), scales = "free")
```

## Further links

-   [Tidy text mining with R](https://www.tidytextmining.com/index.html).
-   A more general [introduction by Christopher Bail](https://cbail.github.io/textasdata/Text_as_Data.html).
-   [A guide to Using spacyr](https://spacy.io/api/token#attributes).
